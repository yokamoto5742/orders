"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var lodash=require("lodash"),path=require("@stoplight/path"),jsoncParser=require("jsonc-parser"),createOrderedObject=require("@stoplight/ordered-object-literal"),createOrderedObject__default=_interopDefault(createOrderedObject),types=require("@stoplight/types"),fastStringify=_interopDefault(require("safe-stable-stringify"));function isPlainObject(e){if("object"!=typeof e||null===e)return!1;const t=Object.getPrototypeOf(e);return null===t||t===Object.prototype||"function"==typeof e.constructor&&Function.toString.call(Object)===Function.toString.call(e.constructor)}function assertResolvableInput(e,t,r){if(!isPlainObject(e)&&!Array.isArray(e)||!(t in e))throw new ReferenceError(`Could not resolve '${r}'`)}function assertObjectWithValidRef(e){if("string"!=typeof e.$ref)throw new TypeError("$ref should be a string")}const hasSomeRef=e=>isPlainObject(e)&&"$ref"in e,hasRef=e=>hasSomeRef(e)&&"string"==typeof e.$ref,isLocalRef=e=>e.length>0&&("#"===e||/^#\S*$/.test(e)),replaceInString=(e,t,r)=>{const n=e.toString();let o="",a=n,i=0,s=a.indexOf(t);for(;s>-1;)o+=n.substring(i,i+s)+r,a=a.substring(s+t.length,a.length),i+=s+t.length,s=a.indexOf(t);return a.length>0&&(o+=n.substring(n.length-a.length,n.length)),o},encodePointerFragment=e=>"number"==typeof e?e:replaceInString(replaceInString(e,"~","~0"),"/","~1"),ENCODABLE_CHAR=/[^a-zA–Z0–9_.!~*'()\/\-\u{D800}-\u{DFFF}]/gu;function encodeUriPointer(e){return e.replace(ENCODABLE_CHAR,encodeURIComponent)}const encodePointerUriFragment=e=>{const t=encodePointerFragment(e);return"number"==typeof t?t:encodeUriPointer(t)},pathToPointer=e=>encodeUriFragmentIdentifier(e),encodeUriFragmentIdentifier=e=>{if(e&&"object"!=typeof e)throw new TypeError("Invalid type: path must be an array of segments.");return 0===e.length?"#":`#/${e.map(encodePointerUriFragment).join("/")}`};function safeDecodeURIComponent(e){try{return decodeURIComponent(e)}catch(t){return e}}const PERCENT_ENCODING_OCTET=/%[0-9a-f]+/gi,decodePointer=e=>{let t;try{t=decodeURIComponent(e)}catch(r){t=e.replace(PERCENT_ENCODING_OCTET,safeDecodeURIComponent)}return replaceInString(replaceInString(t,"~1","/"),"~0","~")},pointerToPath=e=>decodeUriFragmentIdentifier(e),decodeFragmentSegments=e=>{const t=e.length,r=[];let n=-1;for(;++n<t;)r.push(decodePointer(e[n]));return r},decodeUriFragmentIdentifier=e=>{if("string"!=typeof e)throw new TypeError("Invalid type: JSON Pointers are represented as strings.");if(0===e.length||"#"!==e[0])throw new URIError("Invalid JSON Pointer syntax; URI fragment identifiers must begin with a hash.");if(1===e.length)return[];if("/"!==e[1])throw new URIError("Invalid JSON Pointer syntax.");return decodeFragmentSegments(e.substring(2).split("/"))},_traverse=(e,t,r)=>{const n={value:e,path:r};t.onEnter&&t.onEnter(n);for(const n of Object.keys(e)){const o=e[n];t.onProperty&&t.onProperty({parent:e,parentPath:r,property:n,propertyValue:o}),"object"==typeof o&&null!==o&&_traverse(o,t,r.concat(n))}t.onLeave&&t.onLeave(n)},traverse=(e,t)=>{"object"==typeof e&&null!==e&&_traverse(e,"function"==typeof t?{onProperty:t}:t,[])};function remapRefs(e,t,r){traverse(e,{onProperty({property:e,propertyValue:n,parent:o}){"$ref"===e&&"string"==typeof n&&n.startsWith(t)&&(o.$ref=`${r}${n.slice(t.length)}`)}})}const isExternalRef=e=>e.length>0&&"#"!==e[0],extractSourceFromRef=e=>{if("string"!=typeof e||0===e.length||!isExternalRef(e))return null;const t=e.indexOf("#");return-1===t?e:e.slice(0,t)};function applyOverrides(e,t){return isPlainObject(t)&&isPlainObject(e)&&("summary"in e||"description"in e)?Object.assign(Object.assign(Object.assign({},t),"description"in e?{description:e.description}:null),"summary"in e?{summary:e.summary}:null):t}function resolveSource(e,t){const r=extractSourceFromRef(t);return null===r?e:path.isAbsolute(r)?r:path.join(path.dirname(e),r)}function*traverse$1(e,t,r){hasSomeRef(e.value)&&(assertObjectWithValidRef(e.value),yield[-1,e.value]);for(const[n,o]of t.entries())assertResolvableInput(e.value,o,r),e.value=e.value[o],hasSomeRef(e.value)&&(assertObjectWithValidRef(e.value),yield[n,e.value])}function _resolveInlineRefWithLocation(e,t,r,n){if(null!==extractSourceFromRef(t))throw new ReferenceError("Cannot resolve external references");const o=pointerToPath(t);let a=[...o];"#"===t&&hasSomeRef(e)&&(assertObjectWithValidRef(e),o.unshift(...pointerToPath(e.$ref)));const i={value:e};for(const[s,c]of traverse$1(i,o,t)){if(r.includes(c))return{source:null,location:null!=n?n:a,value:r[r.length-1]};r.push(c);const t=_resolveInlineRefWithLocation(e,c.$ref,r,a);i.value=t.value,(a=t.location).push(...o.slice(s+1))}return{source:null,location:a,value:r.length>0?applyOverrides(r[r.length-1],i.value):i.value}}function resolveInlineRef(e,t){return resolveInlineRefWithLocation(e,t).value}function resolveInlineRefWithLocation(e,t){return _resolveInlineRefWithLocation(e,t,[])}const BUNDLE_ROOT="#/__bundled__",ERRORS_ROOT="#/__errors__",bundleTarget=({document:e,path:t,bundleRoot:r=BUNDLE_ROOT,errorsRoot:n=ERRORS_ROOT,cloneDocument:o=!0,keyProvider:a},i)=>{if(t===r||t===n)throw new Error("Roots do not make any sense");const s=o?lodash.cloneDeep(e):e;return bundle(s,pointerToPath(r),pointerToPath(n),t,a)(t,{[t]:!0},i)},defaultKeyProvider=({document:e,path:t})=>{if(0===t.length)return"root";if(Array.isArray(lodash.get(e,t.slice(0,-1)))){return`${t[t.length-2]}_${t[t.length-1]}`}return String(t[t.length-1])},bundle=(e,t,r,n,o)=>{const a=new Set,i=(s,c,l,f={},u={},p={})=>{const h=pointerToPath(s),d=lodash.get(e,h);traverse(l||d,{onEnter:({value:r})=>{if(hasRef(r)&&isLocalRef(r.$ref)){const l=r.$ref;if(p[l])return;if(l===s&&(f[l]="#"),f[l])return void(r.$ref=f[l]);let h,d,g,y,P;try{let r;h=pointerToPath(l),o&&(r=o({document:e,path:h})),r||(r=defaultKeyProvider({document:e,path:h})),g=r;let n=1;for(;a.has(g);)if(g=`${r}_${++n}`,n>20)throw new Error(`Keys ${r}_2 through ${r}_20 already taken.`);a.add(g),d=[...t,g],y=pathToPointer(d)}catch(e){p[l]=e instanceof Error?e.message:String(e)}if(!h||!d||!y)return;if("object"==typeof e&&null!==e&&!(P=lodash.get(e,h)))try{P=resolveInlineRef(Object(e),l)}catch(e){}void 0!==P&&(f[l]=y,r.$ref=y,lodash.has(u,d)||(Array.isArray(P)?lodash.set(u,d,new Array(P.length).fill(null)):"object"==typeof P&&lodash.setWith(u,d,{},Object),lodash.set(u,d,P),"#"===l?bundleRootDocument(e,u,pointerToPath(n),d):c[l]||(c[l]=!0,i(s,c,P,f,u,p),c[l]=!1)))}}});const g=lodash.get(u,t);return g&&Object.keys(g).length&&lodash.set(d,t,g),(Object.keys(p).length||lodash.has(e,r))&&lodash.set(d,r,lodash.has(e,r)?lodash.get(e,r):p),d};return i};function bundleRootDocument(e,t,r,n){const o=r.map(e=>`[${JSON.stringify(e)}]`).join(""),a=JSON.parse(JSON.stringify(lodash.omit(Object(e),o))),i={};lodash.set(t,n,a),lodash.set(a,r,i),remapRefs(a,"#",pathToPointer(n)),i.$ref="#"}const decodePointerFragment=e=>replaceInString(replaceInString(e,"~1","/"),"~0","~"),decycle=(e,t)=>{const r=new WeakMap,n=new WeakSet;return function e(o,a){let i;if(t&&(o=t(o)),isPlainObject(o)||Array.isArray(o)){const t=r.get(o);return t?{$ref:t}:(r.set(o,pathToPointer(a)),Array.isArray(o)?i=o.map((t,r)=>e(t,[...a,String(r)])):(i={},Object.keys(o).forEach(t=>{i[t]=e(o[t],[...a,t])})),n.has(o)||r.delete(o),n.add(o),i)}return o}(e,[])},encodePointer=e=>replaceInString(replaceInString(e,"~","~0"),"//","/~1"),extractPointerFromRef=e=>{if("string"!=typeof e||0===e.length)return null;const t=e.indexOf("#");return-1===t?null:e.slice(t)},getFirstPrimitiveProperty=e=>{const t=jsoncParser.createScanner(e,!0);if(t.scan(),1!==t.getToken())return;if(t.scan(),2===t.getToken())return;if(10!==t.getToken())throw new SyntaxError("Unexpected character");const r=t.getTokenValue();if(t.scan(),6!==t.getToken())throw new SyntaxError("Colon expected");switch(t.scan(),t.getToken()){case 10:return[r,t.getTokenValue()];case 11:return[r,Number(t.getTokenValue())];case 8:return[r,!0];case 9:return[r,!1];case 7:return[r,null];case 16:throw new SyntaxError("Unexpected character");case 17:throw new SyntaxError("Unexpected end of file");default:return}},getJsonPathForPosition=({lineMap:e,ast:t},r)=>{const n=e[r.line],o=e[r.line+1];if(void 0===n)return;const a=jsoncParser.findNodeAtOffset(t,void 0===o?n+r.character:Math.min(o,n+r.character),!0);if(void 0===a)return;const i=jsoncParser.getNodePath(a);return 0!==i.length?i:void 0};function getLastPathSegment(e){return decodePointerFragment(e.split("/").pop()||"")}const getLocationForJsonPath=({ast:e},t,r=!1)=>{const n=findNodeAtPath(e,t,r);if(void 0!==n&&void 0!==n.range)return{range:n.range}};function findNodeAtPath(e,t,r){e:for(const n of t){const t=Number.isInteger(Number(n))?Number(n):n;if("string"==typeof t||"number"==typeof t&&"array"!==e.type){if("object"!==e.type||!Array.isArray(e.children))return r?e:void 0;for(const r of e.children)if(Array.isArray(r.children)&&r.children[0].value===String(t)&&2===r.children.length){e=r.children[1];continue e}return r?e:void 0}if("array"!==e.type||t<0||!Array.isArray(e.children)||t>=e.children.length)return r?e:void 0;e=e.children[t]}return e}const parseWithPointers=(e,t={disallowComments:!0})=>{const r=[],{ast:n,data:o,lineMap:a}=parseTree(e,r,t);return{data:o,diagnostics:r,ast:n,lineMap:a}};function parseTree(e,t=[],r){const n=computeLineMap(e);let o={type:"array",offset:-1,length:-1,children:[],parent:void 0},a=null,i=[];const s=new WeakMap,c=[];function l(e){"property"===o.type&&(o.length=e-o.offset,o=o.parent)}function f(e,t,r){return{start:{line:e,character:t},end:{line:e,character:t+r}}}function u(e){return o.children.push(e),e}function p(e){Array.isArray(i)?i.push(e):null!==a&&(i[a]=e)}function h(e){p(e),c.push(i),i=e,a=null}function d(){i=c.pop()}const g={onObjectBegin:(e,t,n,a)=>{o=u({type:"object",offset:e,length:-1,parent:o,children:[],range:f(n,a,t)}),!1===r.ignoreDuplicateKeys&&s.set(o,[]),h(createObjectLiteral(!0===r.preserveKeyOrder))},onObjectProperty:(e,n,c,l,p)=>{if((o=u({type:"property",offset:n,length:-1,parent:o,children:[]})).children.push({type:"string",value:e,offset:n,length:c,parent:o}),!1===r.ignoreDuplicateKeys){const r=s.get(o.parent);r&&(0!==r.length&&r.includes(e)?t.push({range:f(l,p,c),message:"DuplicateKey",severity:types.DiagnosticSeverity.Error,path:getJsonPath(o),code:20}):r.push(e))}!0===r.preserveKeyOrder&&swapKey(i,e),a=e},onObjectEnd:(e,t,n,a)=>{!1===r.ignoreDuplicateKeys&&s.delete(o),o.length=e+t-o.offset,o.range&&(o.range.end.line=n,o.range.end.character=a+t),o=o.parent,l(e+t),d()},onArrayBegin:(e,t,r,n)=>{o=u({type:"array",offset:e,length:-1,parent:o,children:[],range:f(r,n,t)}),h([])},onArrayEnd:(e,t,r,n)=>{o.length=e+t-o.offset,o.range&&(o.range.end.line=r,o.range.end.character=n+t),o=o.parent,l(e+t),d()},onLiteralValue:(e,t,r,n,a)=>{u({type:getLiteralNodeType(e),offset:t,length:r,parent:o,value:e,range:f(n,a,r)}),l(t+r),p(e)},onSeparator:(e,t)=>{"property"===o.type&&(":"===e?o.colonOffset=t:","===e&&l(t))},onError:(e,r,n,o,a)=>{t.push({range:f(o,a,n),message:jsoncParser.printParseErrorCode(e),severity:types.DiagnosticSeverity.Error,code:e})}};jsoncParser.visit(e,g,r);const y=o.children[0];return y&&delete y.parent,{ast:y,data:i[0],lineMap:n}}function getLiteralNodeType(e){switch(typeof e){case"boolean":return"boolean";case"number":return"number";case"string":return"string";default:return"null"}}const computeLineMap=e=>{const t=[0];let r=0;for(;r<e.length;r++)"\n"===e[r]&&t.push(r+1);return t.push(r+1),t};function getJsonPath(e,t=[]){return"property"===e.type&&t.unshift(e.children[0].value),void 0!==e.parent?("array"===e.parent.type&&void 0!==e.parent.parent&&t.unshift(e.parent.children.indexOf(e)),getJsonPath(e.parent,t)):t}function createObjectLiteral(e){return e?createOrderedObject__default({}):{}}function swapKey(e,t){if(!(t in e))return;const r=createOrderedObject.getOrder(e),n=r.indexOf(t);-1!==n&&(r.splice(n,1),r.push(t))}const renameObjectKey=(e,t,r)=>{if(!e||!Object.hasOwnProperty.call(e,t)||t===r)return e;const n={};for(const[o,a]of Object.entries(e))o===t?n[r]=a:o in n||(n[o]=a);return n};function isObject(e){return isPlainObject(e)||Array.isArray(e)}function reparentBundleTarget(e,t,r){if(r.length<=1||t.length<=1)throw Error("Source/target path must not be empty and point at root");if(0===t.indexOf(r))throw Error("Target path cannot be contained within source");const n=pointerToPath(t);let o=e;for(const e of n){if(!isObject(o))return;o=o[e]}if(!isObject(o))return;const a=pointerToPath(r);let i=e;for(const[e,t]of a.entries()){if(!isObject(i)||t in i)return;const r=e===a.length-1?o:{};i[t]=r,i=r}delete e[n[0]],_reparentBundleTarget(e,t,r)}function _reparentBundleTarget(e,t,r){for(const n of Object.keys(e)){const o=e[n];if("$ref"!==n)isObject(o)&&_reparentBundleTarget(o,t,r);else{if("string"!=typeof o||!isLocalRef(o))continue;0===o.indexOf(t)&&(e[n]=o.replace(t,r))}}}async function _resolveExternalRefWithLocation(e,t,r,n,o){let a=resolveSource(t,r);const i=extractPointerFromRef(r)||"#",s=await e[a],c=pointerToPath(i);let l=[...c];const f={value:s};for(const[r,s]of traverse$1(f,c,i)){if(n.includes(s))return{source:t,location:null!=o?o:l,value:n[n.length-1]};n.push(s);const i=await _resolveExternalRefWithLocation(e,a,s.$ref,n,l);({source:a,location:l}=i),f.value=i.value,l.push(...c.slice(r+1))}return{source:a,location:l,value:n.length>0?applyOverrides(n[n.length-1],f.value):f.value}}async function resolveExternalRef(e,t,r){return(await resolveExternalRefWithLocation(e,t,r)).value}function resolveExternalRefWithLocation(e,t,r){return _resolveExternalRefWithLocation(e,t,r,[])}const safeParse=(e,t)=>{if("string"!=typeof e)return e;try{const r=parseNumber(e);return"string"==typeof r?r:JSON.parse(e,t)}catch(e){return}},parseNumber=e=>{const t=Number(e);return Number.isFinite(t)?String(t)===e?t:e:NaN},safeStringify=(e,t,r)=>{if("string"==typeof e)return e;try{return JSON.stringify(e,t,r)}catch(n){return fastStringify(e,t,r)}},startsWith=(e,t)=>{if(e instanceof Array){if(t instanceof Array){if(t.length>e.length)return!1;for(const r in t){if(!t.hasOwnProperty(r))continue;const n=parseInt(e[r]),o=parseInt(t[r]);if(isNaN(n)&&isNaN(o)){if(e[r]!==t[r])return!1}else if(n!==o)return!1}}}else{if("string"!=typeof e)return!1;if("string"==typeof t)return e.startsWith(t)}return!0},stringify=(e,t,r)=>{const n=safeStringify(e,t,r);if(void 0===n)throw new Error("The value could not be stringified");return n};function toPropertyPath(e){return e.replace(/^(\/|#\/)/,"").split("/").map(decodePointerFragment).map(sanitize).join(".")}function sanitize(e){return e.includes(".")?`["${e.replace(/"/g,'\\"')}"]`:e}const KEYS=Symbol.for(createOrderedObject.ORDER_KEY_ID),traps={ownKeys:e=>KEYS in e?e[KEYS]:Reflect.ownKeys(e)},trapAccess=e=>new Proxy(e,traps);function trimStart(e,t){if("string"==typeof e&&"string"==typeof t)return lodash.trimStart(e,t);if(!(e&&Array.isArray(e)&&e.length&&t&&Array.isArray(t)&&t.length))return e;let r=0;for(const n in e)if(e.hasOwnProperty(n)){if(e[n]!==t[n])break;r++}return e.slice(r)}exports.BUNDLE_ROOT=BUNDLE_ROOT,exports.ERRORS_ROOT=ERRORS_ROOT,exports.KEYS=KEYS,exports.bundleTarget=bundleTarget,exports.decodePointer=decodePointer,exports.decodePointerFragment=decodePointerFragment,exports.decodePointerUriFragment=decodePointer,exports.decycle=decycle,exports.encodePointer=encodePointer,exports.encodePointerFragment=encodePointerFragment,exports.encodePointerUriFragment=encodePointerUriFragment,exports.encodeUriPointer=encodeUriPointer,exports.extractPointerFromRef=extractPointerFromRef,exports.extractSourceFromRef=extractSourceFromRef,exports.getFirstPrimitiveProperty=getFirstPrimitiveProperty,exports.getJsonPathForPosition=getJsonPathForPosition,exports.getLastPathSegment=getLastPathSegment,exports.getLocationForJsonPath=getLocationForJsonPath,exports.hasRef=hasRef,exports.isExternalRef=isExternalRef,exports.isLocalRef=isLocalRef,exports.isPlainObject=isPlainObject,exports.parseTree=parseTree,exports.parseWithPointers=parseWithPointers,exports.pathToPointer=pathToPointer,exports.pointerToPath=pointerToPath,exports.remapRefs=remapRefs,exports.renameObjectKey=renameObjectKey,exports.reparentBundleTarget=reparentBundleTarget,exports.resolveExternalRef=resolveExternalRef,exports.resolveExternalRefWithLocation=resolveExternalRefWithLocation,exports.resolveInlineRef=resolveInlineRef,exports.resolveInlineRefWithLocation=resolveInlineRefWithLocation,exports.safeParse=safeParse,exports.safeStringify=safeStringify,exports.startsWith=startsWith,exports.stringify=stringify,exports.toPropertyPath=toPropertyPath,exports.trapAccess=trapAccess,exports.traverse=traverse,exports.trimStart=trimStart;
